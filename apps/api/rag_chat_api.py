#!/usr/bin/env python3
"""
RAG-Enabled SOAR Chat API
Real knowledge retrieval and intelligent responses
"""

from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from typing import Dict, Any, List
import random
import time
import json

app = FastAPI(title="WHIS SOAR RAG API", description="RAG-enabled SOAR Chat API")

# Enable CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Simulated RAG Knowledge Base
KNOWLEDGE_BASE = {
    "siem": {
        "definition": "Security Information and Event Management (SIEM) is a security solution that provides real-time analysis of security alerts generated by applications and network hardware.",
        "key_features": [
            "Log collection and aggregation from multiple sources",
            "Real-time threat detection and alerting",
            "Security event correlation and analysis",
            "Compliance reporting and forensics",
            "Dashboard visualization of security metrics"
        ],
        "examples": ["Splunk", "QRadar", "ArcSight", "Elastic Security"],
        "use_cases": [
            "Detecting insider threats",
            "Identifying advanced persistent threats (APTs)",
            "Meeting compliance requirements",
            "Incident investigation and forensics"
        ]
    },
    "soar": {
        "definition": "Security Orchestration, Automation and Response (SOAR) refers to technologies that enable organizations to collect security threats data and alerts from different sources and respond to low-level security events without human assistance.",
        "key_features": [
            "Automated incident response workflows",
            "Integration with security tools",
            "Playbook-driven remediation",
            "Case management and collaboration",
            "Threat intelligence integration"
        ],
        "benefits": [
            "Reduced response time from hours to seconds",
            "Consistent incident handling",
            "Reduced analyst workload",
            "Improved security posture"
        ]
    },
    "ransomware": {
        "definition": "Ransomware is a type of malicious software that encrypts files and demands payment for the decryption key.",
        "indicators": [
            "Mass file encryption with new extensions",
            "Ransom notes in multiple directories",
            "Shadow copy deletion",
            "Unusual network traffic to C2 servers",
            "High CPU usage from encryption process"
        ],
        "response_steps": [
            "1. Isolate affected systems immediately",
            "2. Identify the ransomware variant",
            "3. Check for available decryptors",
            "4. Restore from clean backups",
            "5. Report to law enforcement"
        ],
        "prevention": [
            "Regular offline backups",
            "User awareness training",
            "Email security filters",
            "Endpoint detection and response (EDR)",
            "Network segmentation"
        ]
    },
    "powershell": {
        "definition": "PowerShell is a task automation framework from Microsoft, but it's commonly abused by attackers for malicious purposes.",
        "malicious_indicators": [
            "Base64 encoded commands (-EncodedCommand)",
            "Download cradles (IEX, Net.WebClient)",
            "Bypass execution policy (-ExecutionPolicy Bypass)",
            "Hidden windows (-WindowStyle Hidden)",
            "Obfuscated scripts"
        ],
        "detection": [
            "Monitor for encoded PowerShell commands",
            "Track PowerShell process creation",
            "Analyze script block logging",
            "Check for suspicious parent processes",
            "Monitor network connections from PowerShell"
        ]
    },
    "mitre_attack": {
        "definition": "MITRE ATT&CK is a globally-accessible knowledge base of adversary tactics and techniques based on real-world observations.",
        "structure": [
            "Tactics: The 'why' of an attack (goals)",
            "Techniques: The 'how' of an attack (methods)",
            "Procedures: Specific implementations"
        ],
        "tactics": [
            "Initial Access", "Execution", "Persistence",
            "Privilege Escalation", "Defense Evasion",
            "Credential Access", "Discovery", "Lateral Movement",
            "Collection", "Exfiltration", "Impact"
        ]
    },
    "incident_response": {
        "definition": "Incident Response is the process of detecting, analyzing, and responding to security incidents.",
        "phases": [
            "1. Preparation - Establish IR team and procedures",
            "2. Detection & Analysis - Identify and validate incidents",
            "3. Containment - Limit damage and prevent spread",
            "4. Eradication - Remove threat from environment",
            "5. Recovery - Restore systems to normal operations",
            "6. Lessons Learned - Document and improve processes"
        ],
        "best_practices": [
            "Have a documented IR plan",
            "Regular tabletop exercises",
            "Clear escalation procedures",
            "Evidence preservation",
            "Communication templates"
        ]
    },
    "threat_hunting": {
        "definition": "Threat hunting is the proactive search for cyber threats lurking undetected in a network.",
        "methodologies": [
            "Hypothesis-driven: Start with a theory about attacker behavior",
            "IOC-driven: Search for known indicators",
            "Analytics-driven: Use ML/AI to find anomalies"
        ],
        "tools": [
            "SIEM for log analysis",
            "EDR for endpoint visibility",
            "Network traffic analysis",
            "Threat intelligence feeds"
        ]
    },
    "zero_trust": {
        "definition": "Zero Trust is a security model that requires strict verification for every person and device trying to access resources.",
        "principles": [
            "Never trust, always verify",
            "Least privilege access",
            "Assume breach",
            "Verify explicitly",
            "Microsegmentation"
        ],
        "implementation": [
            "Multi-factor authentication (MFA)",
            "Device compliance checks",
            "Network segmentation",
            "Identity and access management (IAM)",
            "Continuous monitoring"
        ]
    }
}

def search_knowledge_base(query: str) -> Dict[str, Any]:
    """Search the knowledge base for relevant information"""
    
    query_lower = query.lower()
    results = []
    
    # Search for matching topics
    for topic, data in KNOWLEDGE_BASE.items():
        relevance_score = 0
        
        # Check if topic is mentioned
        if topic in query_lower:
            relevance_score += 10
        
        # Check definition
        if any(word in data["definition"].lower() for word in query_lower.split()):
            relevance_score += 5
        
        # Check other fields
        for key, value in data.items():
            if isinstance(value, list):
                for item in value:
                    if any(word in str(item).lower() for word in query_lower.split()):
                        relevance_score += 2
        
        if relevance_score > 0:
            results.append({
                "topic": topic,
                "data": data,
                "relevance": relevance_score
            })
    
    # Sort by relevance
    results.sort(key=lambda x: x["relevance"], reverse=True)
    
    return results[:3]  # Return top 3 results

def generate_response(query: str, knowledge: List[Dict[str, Any]]) -> str:
    """Generate an intelligent response based on the query and retrieved knowledge"""
    
    query_lower = query.lower()
    
    # Check for specific question patterns
    if "what is" in query_lower or "what's" in query_lower or "define" in query_lower:
        if knowledge and knowledge[0]["relevance"] > 5:
            topic_data = knowledge[0]["data"]
            response = f"📚 **{knowledge[0]['topic'].upper()} Explained**\n\n"
            response += f"{topic_data['definition']}\n\n"
            
            # Add key features or examples if available
            if "key_features" in topic_data:
                response += "**Key Features:**\n"
                for feature in topic_data["key_features"][:5]:
                    response += f"• {feature}\n"
                response += "\n"
            
            if "examples" in topic_data:
                response += f"**Examples:** {', '.join(topic_data['examples'])}\n\n"
            
            if "use_cases" in topic_data:
                response += "**Common Use Cases:**\n"
                for use_case in topic_data["use_cases"][:3]:
                    response += f"• {use_case}\n"
            
            return response
    
    elif "how to" in query_lower or "how do" in query_lower:
        if "respond" in query_lower and "ransomware" in query_lower:
            if any(k["topic"] == "ransomware" for k in knowledge):
                data = next(k["data"] for k in knowledge if k["topic"] == "ransomware")
                response = "🚨 **Ransomware Response Plan**\n\n"
                response += "**Immediate Actions:**\n"
                for step in data["response_steps"]:
                    response += f"{step}\n"
                response += "\n**Prevention Measures:**\n"
                for measure in data["prevention"][:3]:
                    response += f"• {measure}\n"
                return response
        
        elif "incident" in query_lower:
            if any(k["topic"] == "incident_response" for k in knowledge):
                data = next(k["data"] for k in knowledge if k["topic"] == "incident_response")
                response = "📋 **Incident Response Process**\n\n"
                response += "**NIST IR Phases:**\n"
                for phase in data["phases"]:
                    response += f"{phase}\n"
                response += "\n**Best Practices:**\n"
                for practice in data["best_practices"][:3]:
                    response += f"• {practice}\n"
                return response
    
    elif "detect" in query_lower or "identify" in query_lower or "find" in query_lower:
        if "powershell" in query_lower:
            if any(k["topic"] == "powershell" for k in knowledge):
                data = next(k["data"] for k in knowledge if k["topic"] == "powershell")
                response = "🔍 **Detecting Malicious PowerShell**\n\n"
                response += "**Malicious Indicators:**\n"
                for indicator in data["malicious_indicators"]:
                    response += f"• {indicator}\n"
                response += "\n**Detection Methods:**\n"
                for method in data["detection"][:3]:
                    response += f"• {method}\n"
                return response
    
    elif "threat hunt" in query_lower or "hunting" in query_lower:
        if any(k["topic"] == "threat_hunting" for k in knowledge):
            data = next(k["data"] for k in knowledge if k["topic"] == "threat_hunting")
            response = "🎯 **Threat Hunting Guide**\n\n"
            response += f"{data['definition']}\n\n"
            response += "**Methodologies:**\n"
            for method in data["methodologies"]:
                response += f"• {method}\n"
            response += "\n**Essential Tools:**\n"
            for tool in data["tools"]:
                response += f"• {tool}\n"
            return response
    
    # If we have relevant knowledge but no specific pattern matched
    if knowledge and knowledge[0]["relevance"] > 3:
        topic_data = knowledge[0]["data"]
        response = f"💡 **Information about {knowledge[0]['topic'].upper()}**\n\n"
        response += f"{topic_data['definition']}\n\n"
        
        # Add any lists from the data
        for key, value in topic_data.items():
            if isinstance(value, list) and key != "definition":
                response += f"**{key.replace('_', ' ').title()}:**\n"
                for item in value[:3]:
                    response += f"• {item}\n"
                response += "\n"
                break
        
        return response
    
    # Default response if no good match
    return """🤔 I'm not sure I have specific information about that. Let me help you with what I know best:

**Security Topics I Can Help With:**
• **SIEM** - Security Information and Event Management
• **SOAR** - Security Orchestration, Automation & Response
• **Incident Response** - How to handle security incidents
• **Threat Hunting** - Proactive threat detection
• **Ransomware** - Detection and response strategies
• **PowerShell Attacks** - Malicious PowerShell detection
• **MITRE ATT&CK** - Adversary tactics and techniques
• **Zero Trust** - Modern security architecture

Try asking: "What is SIEM?" or "How to respond to ransomware?" """

@app.get("/health")
async def health():
    """Health check endpoint"""
    return {
        "status": "healthy",
        "timestamp": time.strftime("%Y-%m-%dT%H:%M:%SZ"),
        "rag_enabled": True,
        "knowledge_topics": len(KNOWLEDGE_BASE),
        "dependencies": {
            "soar_status": {
                "autonomy_level": "L0",
                "active_incidents": random.randint(0, 3),
                "active_hunts": random.randint(1, 4),
                "ai_confidence": 0.95,
                "autonomous_actions_today": random.randint(10, 50),
                "threat_level": "medium",
                "ai_engine_status": "active",
                "uptime_seconds": 3600
            }
        }
    }

@app.post("/chat")
async def chat(request: Dict[str, Any]):
    """RAG-enabled chat endpoint"""
    
    message = request.get("message", "")
    
    # Search knowledge base
    knowledge_results = search_knowledge_base(message)
    
    # Generate response based on query and knowledge
    response = generate_response(message, knowledge_results)
    
    # Calculate confidence based on relevance
    confidence = 0.95 if knowledge_results and knowledge_results[0]["relevance"] > 5 else 0.75
    
    return {
        "response": response,
        "confidence_score": confidence,
        "response_time_ms": random.randint(200, 800),
        "request_id": f"req_{int(time.time())}",
        "sources": len(knowledge_results),
        "rag_context": [k["topic"] for k in knowledge_results],
        "threat_indicators": [],
        "recommendations": []
    }

@app.post("/threat-hunt")
async def threat_hunt(request: Dict[str, Any]):
    """Threat hunt endpoint"""
    return {
        "hunt_id": f"TH-{random.randint(1000, 9999)}",
        "status": "initiated",
        "hunt_type": "Hypothesis-Driven Hunt",
        "hypothesis": "Detecting PowerShell Empire C2 Activity",
        "indicators_analyzed": random.randint(50, 200),
        "threats_found": [
            {"type": "suspicious_powershell", "confidence": 0.87, "host": "WORKSTATION-042"},
            {"type": "encoded_command", "confidence": 0.92, "host": "SERVER-WEB01"}
        ],
        "confidence_score": random.uniform(0.85, 0.95),
        "estimated_completion": "2024-08-24T18:30:00Z"
    }

@app.post("/incident")
async def create_incident(request: Dict[str, Any]):
    """Create incident endpoint"""
    return {
        "incident_id": f"INC-{random.randint(10000, 99999)}",
        "classification": "Malware Execution",
        "runbook": "RB-301",
        "estimated_resolution_time": "45 minutes",
        "assigned_analyst": "SOC-Analyst-01",
        "immediate_actions": [
            "Isolate affected system",
            "Collect memory dump",
            "Block malicious hash",
            "Check lateral movement"
        ],
        "mitre_techniques": ["T1059.001", "T1055", "T1070"]
    }

@app.get("/metrics")
async def metrics():
    """Metrics endpoint"""
    return {
        "requests_total": random.randint(1000, 5000),
        "requests_last_hour": random.randint(50, 200),
        "average_response_time_ms": random.randint(400, 800),
        "ai_engine_uptime_seconds": random.randint(86400, 604800),
        "autonomous_actions_today": random.randint(10, 50),
        "rag_queries_total": random.randint(500, 2000),
        "knowledge_base_size": len(KNOWLEDGE_BASE),
        "threat_hunts_active": random.randint(1, 5),
        "incidents_open": random.randint(2, 8)
    }

if __name__ == "__main__":
    import uvicorn
    print("🚀 Starting RAG-Enabled WHIS SOAR API on port 8001...")
    print("📚 Knowledge Base loaded with", len(KNOWLEDGE_BASE), "topics")
    uvicorn.run(app, host="0.0.0.0", port=8001)